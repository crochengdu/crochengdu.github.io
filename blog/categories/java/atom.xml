<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | CRO-成都学习天地]]></title>
  <link href="http://crochengdu.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://crochengdu.github.io/"/>
  <updated>2014-06-09T13:20:19+08:00</updated>
  <id>http://crochengdu.github.io/</id>
  <author>
    <name><![CDATA[运营支撑团队]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于Java异常的那些事儿]]></title>
    <link href="http://crochengdu.github.io/blog/2014/06/09/java-exception/"/>
    <updated>2014-06-09T10:32:40+08:00</updated>
    <id>http://crochengdu.github.io/blog/2014/06/09/java-exception</id>
    <content type="html"><![CDATA[<h1>一、 Exception</h1>

<h2>1.    Exception定义</h2>

<p>在有充足理由将某情况视为该方法的典型功能（typical functioning ）部分时，避免使用异常。　因此，意外情况就是指方法的“正常功能”（normal functioning）之外的情况。</p>

<h2>2.    Exception分类</h2>

<p>Checked Exception:  Java.lang.Exception的子类,方法签名上需要显示的声明throws，编译器迫使调用者处理这类异常或者声明throws继续往上抛。主要是对付那些可以恢复过来的场景。</p>

<p>Unchecked Exception:  RuntimeException的子类，方法签名不需要声明throws，编译器也不会强制调用者处理该类异常。主要用于那些无法恢复的场景。</p>

<p>当要决定是采用checked exception还是Unchecked exception的时候，你要问自己一个问题，"如果这种异常一旦抛出，客户端会做怎样的补救？"
如果客户端可以通过其他的方法恢复异常，那么这种异常就是checked exception；
如果客户端对出现的这种异常无能为力，那么这种异常就是Unchecked exception；从使用上讲，当异常出现的时候要做一些试图恢复它的动作而不要仅仅的打印它的信息。</p>

<h2>3.    异常的优缺点</h2>

<p>优点：</p>

<pre><code>    1). 分离错误代码和正常代码，代码更简洁。 
    2). 保护数据的正确性和完整性，程序更严谨及更健壮。 
    3). 便于调试和排错，软件更好维护。
</code></pre>

<p>缺点：
1). 过度或者错误使用异常会导致消耗过多的资源。
2). 有些被定义为Checked Exception的，在某些情况下并不被视为异常情况。</p>

<h2>4.    异常处理原则：</h2>

<p>第1条: 只针对不正常的情况才使用异常
1)  异常应该只用于异常的情况下，不该用于正常的控制流
2)  设计良好的API不应该强迫它的客户端为了正常的控制流而使用异常，可以提供状态测试（hashNext()）或者可识别的返回值(return null)。</p>

<p>第2条: 对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常
java有三种可抛出的结构（throwable），受检的异常（checked exception）、运行时异常（run-time exception）和错误（error）。</p>

<p>第3条: 避免不必要的使用被检查的异常
如果正确地使用API并不能阻止这种异常条件的产生，并且一旦产生异常，使用API的程序员可以立即采取有用的动作，这种负担就被认为是正当的。除非这两个条件都成立，否则更适合于使用未受检的异常
第4条: 尽量使用标准的异常
第5条: 抛出的异常要适合于相应的抽象
1)  更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常，即异常转译（Exception translation）
2)  异常链，低层的异常对于调试导致高层异常的问题有帮助的时候使用
3)  尽管异常转译与不加选择第从底层传递异常的做法相比有所改进，但是它也不能被滥用。如果可能，处理来自低层异常的最好做法是，在调用低层方法之前确保它们会成功执行，从而避免它们抛出异常。如在给低层传递参数之前，检查高层参数有效性，从而避免低层抛出异常
4)  如果无法避免低层异常，次选是，让更高层来悄悄绕开这些异常，从而将高层方法的调用者与低层的问题隔离开来。如使用java.util.logging将异常记录下来。</p>

<p>第6条: 每个方法抛出的 异常都要有文档
第7条: 在细节消息中包含失败 &mdash; 捕获消息
第8条: 努力使失败保持原子性，一般而言，失败的方法调用应该使对象保持在被调用之前的状态。具有这种熟悉的方法被成为具有失败原子性（failure atomic）。
1)  最简单的办法莫过于设计一个不可变的对象，如果对象不可变，失败原子性就是显然的了
2)  对于在可变对象上执行操作的方法，获得原子性最常见的办法是，在执行操作之前检查参数的有效性。
3)  做恢复代码，回滚
4)  在对象的临时拷贝上进行操作，完成之后在用临时拷贝中的结构代替对象的内容。
5)  一般而言，作为方法规范的一部分，产生任何异常都应该让对象保持在该方法调用之前的状态。如果违反这条规则，API文档就应该清楚地指明对象将会处于什么样的状态。</p>

<p>第9条: 不要忽略异常
1)  当api的设计者声明一个方法将抛出某个异常的时候，他们等于正在试图说明某些事情，因此不要忽略它。
2)  空的catch使异常达不到应有的目的，至少，catch块也应该保护一条说明，解释为什么可以忽略这个异常</p>

<h2>5.    Exception实例</h2>

<h3>5.1  Exception顺序</h3>

<p>```java
try {</p>

<pre><code>    throw new FileNotFoundException();
}  catch (FileNotFoundException file) {
    System.out.println("File Not Found Exception");
} catch (IOException io) {
    System.out.println("IO Exception");
}
</code></pre>

<p>```
IOException 只会catch住非FileNotFoundException以外的exception, 交换2个位置，是会编译出错的，会提示FileNotFoundException已经被catch住了。</p>

<h3>5.2  Exception Wrapper</h3>

<p> Exception Wrapper, 聚合这些exception, 在调用栈的顶部，封装下exception, 让上次不要知道底层这么多细节。</p>

<p>如果在catch或者finally的时候，抛出一个exception, 那么这个exception hide住了本来catch住的exception.</p>

<p>不好的实例：
```java</p>

<pre><code>InputStream input = null;
  try{
    input = new FileInputStream("myFile.txt");
    //do something with the stream
  } catch(IOException e){
    throw new WrapperException(e);
  } finally {
    try{
     input.close();
    } catch(IOException e){
       throw new WrapperException(e);
    }
  }
</code></pre>

<p>```</p>

<p>正确的写法：
```java</p>

<pre><code>try{
    input = new FileInputStream("myFile.txt");
    //do something with the stream
  } catch(IOException e){ //first catch block
    throw new WrapperException(e);
  } finally {
    try{
     if(input != null) input.close();
    } catch(IOException e){  //second catch block
       throw new WrapperException(e);
    }
  }
</code></pre>

<p>```
我们必须保证的是，最后一个exception必须throw 所有exceptions情况，其实这还不是最复杂的情况。在jdbc transations里面，情况更为复杂。</p>

<h3>5.3   UndeclaredThrowableException</h3>

<p>JDK的java doc是这么解释UndeclaredThrowableException的：
<a href="http://download.oracle.com/technetwork/java/javase/6/docs/zh/api/java/lang/reflect/UndeclaredThrowableException.html">http://download.oracle.com/technetwork/java/javase/6/docs/zh/api/java/lang/reflect/UndeclaredThrowableException.html</a>
英文版的：
<a href="http://pic.dhe.ibm.com/infocenter/adiehelp/v5r1m1/index.jsp?topic=%2Fcom.sun.api.doc%2Fjava%2Flang%2Freflect%2FUndeclaredThrowableException.html">http://pic.dhe.ibm.com/infocenter/adiehelp/v5r1m1/index.jsp?topic=%2Fcom.sun.api.doc%2Fjava%2Flang%2Freflect%2FUndeclaredThrowableException.html</a></p>

<p>明白了什么是UndeclaredThrowableException后，那我就查我的代码中时什么原因导致了这个exception：
这是因为通过反射调用抛出的异常被代理类包装为UndeclaredThrowableException
这个异常总共途径了一下几个系统：
RPC client(源头)&mdash;&ndash;>我的应用&mdash;&mdash;>Web容器(容器层)
那么我们来分析下，分别在那一层处理这个异常比较合适。
1、 源头RPC client层：我认为，判断一处代码是应该处理异常还是将异常抛出，取决于其是否获取了异常信息后，能如何应对？如果其能针对捕捉到的异常做出符合业务逻辑需要的处理，那么就不应该将异常继续抛出，反之，则抛出异常。比如上面的TimeOutException，不同应用的业务逻辑有不同的处理办法，而RPC Client端并不知道这个具体的情况，所以RPC Client不需要处理这类异常，将其继续抛出即可。越接近异常的源头，处理异常最方便（此处的方便，指的是，在接近于源头的底层框架处理异常，那么对调用这些框架的应用代码来说，就不需要关注异常处理了，这就方便了
2、 应用层：那么是不是需要在应用层做处理呢？这里需要具体情况具体分析。拿我这个应用来说，这是一个web应用，就算我这个应用对runtimeException不做处理，web容器也会对这个异常进行处理，并不会造成程序的崩溃。但是如果应用层不是web项目，或者应用不是依托在某个容器内，那如果应用层不对这个异常进行处理的话，就没人处理这个异常了，就会直接抛出一个RuntimeException，导致程序挂掉。因此我认为，如果我们在应用中调用RPC等之类的服务，要注意一下几点：
此处的调用抛了UndeclaredThrowableException，需要额外的处理不?
如果需要，就要在此处捕捉到这个异常；
如果不需要，那么就要想想，我们的应用把这个异常抛出去，接下来会不会有地方来处理这个异常，如果有，则可以继续抛出？
如果我们的应用已经是异常处理链中的最后一环，那么还是要把这个异常捕捉住。
如果有Web容器之类的罩着，我们可以把这个异常继续传递下去。
如果在应用中要处理异常，应该考虑的全面细致。是否需要降级？该流程是否是必须流程，如果是必须流程是否还会涉及到业务回滚，如果是非必须流程如何在产生异常时不影响当前业务。是否需要容灾？
3、 Web容器：上面说了，如果是Web项目，容器会处理应用抛出的RuntimeException，就像上面图展示的 Webx3容器（jboss）的默认Error页面。
另外， 对于RPC之类等涉及网络的服务调用，需要养成一个多思考一点的异常处理的编程习惯。</p>

<h3>5.4  异常的性能问题</h3>

<p>1)  问题存在
是否使用异常来控制业务流程，是个比较争议的话题。支持的人认为，使用业务异常来控制业务流程，代码逻辑清晰，反对的人认为异常消耗太多资源，对系统的性能有影响。那我们做个测试，看看异常是否会影响性能。
首先定义一个普通的业务异常，代码如下:
```java
public class BusinessException extends Exception {</p>

<pre><code>private static final long serialVersionUID = 8186919518812720632L;
public BusinessException(String message, Throwable cause) {
    super(message, cause);
}
public BusinessException(String message) {
    super(message);
}
</code></pre>

<p>}
<code>
然后测试对比，生成业务异常对象和生成普通对象的耗时分别是多少，代码如下:
</code>java
long startTime = System.currentTimeMillis();                      <br/>
for (int i = 0; i &lt; 2000000; i++) {</p>

<pre><code>new HashMap&lt;String, String&gt;();                                                   
</code></pre>

<p>}                                                                 <br/>
long endTime = System.currentTimeMillis();                        <br/>
System.out.println(&ldquo;HashMap:&rdquo; + (endTime &ndash; startTime));</p>

<p>startTime = System.currentTimeMillis();                           <br/>
for (int i = 0; i &lt; 2000000; i++) {</p>

<pre><code>new BusinessException("exception test");                        
</code></pre>

<p>}                                                                 <br/>
endTime = System.currentTimeMillis();                             <br/>
System.out.println(&ldquo;BusinessException:&rdquo; + (endTime &ndash; startTime)); <br/>
<code>
最后的执行结果如下：
</code>java
HashMap:24
BusinessException:916
<code>
2)  原因分析
可见生成普通HashMap对象和普通业务异常对象的耗时不在一个数量级，那我们看看生成业务异常对象，做了哪些事情，查看Exception的父类Throwable的构造函数，发现构造普通业务异常对象的时候，会调用synchronized声明的方法fillInStackTrace，代码如下：
</code>java
public Throwable(String message) {</p>

<pre><code>    fillInStackTrace();
    detailMessage = message;
}
</code></pre>

<p><code>
性能的主要开销就在这个方法，作用是填充线程运行堆栈信息，其实定义业务异常是为了用于控制业务逻辑，为可检查异常，其堆栈信息没有多大用处，生成业务异常的时候，没有必要填充堆栈信息。
3)  解决方法
对BusinessException做了改进，代码如下：
</code>java
public class SterilizedBusinessException extends Exception {</p>

<pre><code>private static final long serialVersionUID = -722749368211888466L;
public SterilizedBusinessException(String message, Throwable cause) {
    super(message, cause);
}
public SterilizedBusinessException(String message) {
    super(message);
}
@Override
public Throwable fillInStackTrace() {
    return null;
}
</code></pre>

<p>}
<code>
对方法fillInStackTrace进行了重写，此时我们再测试一次，结果如下：
</code>java
HashMap:25
BusinessException:23
```
此时就不会因为业务异常而影响系统性能。</p>

<h3>5.5  运行时异常和可检查异常的差别</h3>

<p>这个差别主要表现在编程时和运行时，编程时差别大家都比较清楚， checked异常总是需要显式处理，
而unchecked异常可以选择性处理，那么在运行时呢，这两个异常JVM处理上面是否存在很大的差异？
1)  Java文件：
```java
package com.test.jingchu;</p>

<p>public class ExceptionTest2 {</p>

<pre><code>public static void main(String[] args) {
    try {
        getResult1();
    } catch (MyException e) {
        System.out.println("MyException");
    }
    try {
        getResult2();
    } catch (IllegalArgumentException e) {
        System.out.println("IllegalArgumentException");
    }
}

public static String getResult1() throws MyException {
    throw new MyException();
}

public static String getResult2() {
    throw new IllegalArgumentException();
}
</code></pre>

<p>}
```</p>

<p>2)  class阉割
将编译好的class 文件使用二进制方式打开，找到如下位置：
<img class="center" src="/images/class1.png" width="380" height="320"></p>

<p>我们 将绿色部分修改成0001 ， 将红色部分删除：
<img class="center" src="/images/class2.png" width="380" height="320"></p>

<p>3)  反编译
将该class 反编译成java :
<img class="center" src="/images/class3.png" width="380" height="320">
我们会发现 getResult1() 的方法的throws 信息被我们阉割掉了。
4)  运行
继续运行该class 打印结果：
<img class="center" src="/images/class4.png" width="380" height="320">
5)  结论
checked 异常的throws 语句不影响class 文件的加载，且在运行时JVM没有区分这两类异常。也就是说异常机制其实在运行设计上面是没有任何差别的， 但是在使用设计上面却存在很大的差别。</p>

<h2>6.    Java-7中新增exception特性</h2>

<h3>6.1    特性一 Java 7 Try-with-resourcce</h3>

<p>```java</p>

<pre><code>private static void printFile() throws IOException {
    InputStream input = null;
    try {
        input = new FileInputStream("file.txt");
        int data = input.read();
        while(data != -1){
            System.out.print((char) data);
            data = input.read();
        }
    } finally {
        }
    }
}
        if(input != null){
            input.close();
        }
    }
}
</code></pre>

<p><code>
在JSR 334, Project Coin
</code>java</p>

<pre><code>private static void printFileJava7() throws IOException {

    try(FileInputStream input = new FileInputStream("file.txt")) {

        int data = input.read();
        while(data != -1){
            System.out.print((char) data);
            data = input.read();
        }
    }
}
</code></pre>

<p>```
这个FileInputStream会在try block完成时，被自动关掉，因为FileInputStream实现了Java.lang.AutoCloseable接口，所有class实现了这个接口，都可以用在try-with-resources结果里面。</p>

<p>当多个Resouces申明了以后，</p>

<pre><code>try( FileInputStream   input    = new FileInputStream("file.txt");
        BufferedInputStream bufferedInput = new BufferedInputStream(input)
   ) {
</code></pre>

<p>input, bufferedInput都会自动关闭，但是他们关闭的顺序正好和他们申明顺序相反。</p>

<h3>6.2    特性二 Java7 之前我们catch住多个Exception</h3>

<p>```java</p>

<pre><code>try {
    // execute code that may throw 1 of the 3 exceptions below.
} catch(SQLException) {
    logger.log(e);
} catch(IOException e) {
    logger.severe(e);
}catch(Exception e) {
    logger.severe(e);
}
</code></pre>

<p><code>
Java 7之后 我们可以用
</code>java</p>

<pre><code>try {
    // execute code that may throw 1 of the 3 exceptions below.
} catch(SQLException | IOException e) {
    logger.log(e); 
} catch(Exception e) {
    logger.severe(e);
}
</code></pre>

<p>```</p>

<p>如果用一个比较大的父类的Exception, 这会造成上层用户，很难知道到底发生了什么。
7.  异常实现原理（JVM）
JVM对异常的处理主要是基于异常表(Exception Table)，每个包含了try的方法在编译后除字节码外，都会产生一个附加的数据结构&mdash;异常表，异常表结构如下：</p>

<pre><code>{
    {PC:BEGIN, PC:END, PC:HANDLER, EXCEPTION-TYPE}
}
PC:BEGIN-PC:END 代表异常发生的PC值的范围
EXCEPTION-TYPE   代表异常捕获的类型
PC:HANDLER          代表异常处理的指针
</code></pre>

<p>当JVM的方法产生异常后，按照以下步骤执行异常处理：
1. JVM会在当前Frame的Exception Table里面逐条查找PC范围和异常类型匹配的记录。
并将PC跳转到对应的异常处理的位置上。
注意：类型符合不是完全匹配，而是符合向上原则，即父类的catch可以捕获子类的对象,即 e instance of CLASS。
2. 如果当前Frame不存在Exception Table, 或者在Exception Table里找不到匹配的记录，则当前Frame出栈，把当前Frame设置成上一个Frame，获得新的当前pc和当前异常表。
3. 继续执行1，直到JAVA STACK到达栈底还不能匹配，则异常未处理，抛出到JRE。</p>

<p>个人理解：JVM是基于所谓的栈帧的(stack frame)的，一个函数调用链就是一个个栈帧组成，当在一个栈里用athrow抛出异常时，JVM会搜索当前函数的异常处理表（参考下面的Class文件分析），如果有找到对应的异常处理的handler，则由这个handler来处理。如果没有，则清理当前栈，再回到上一层栈帧中处理。如果一层层栈帧回退，最
athrow指令：
在JVM里实现异常的指令是athrow，指令的参考在这里：<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.athrow">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.athrow</a>
终都没有找到Exception Handler，则线程终止。</p>

<h2>8.    带finally的异常处理</h2>

<p>如果异常处理带有finally块，字节码的处理同上面的异常处理流程一致，
JVM并不需要为此机制作出改动。编译器通过内联函数和扩展异常表来实现的这个过程。
可以这么理解finally，有异常发生的时候，可以理解为一个可以捕获方法内任何异常（包含try块中的异常和catch块中的异常）并自动重新抛出的catch段。
在没有异常，或者异常被捕获的过程，以字节码内联的方式将finally段内容自动添加到对应的段后，然后自动执行。
注意：如果finally段内如果有return关键字的话，异常已经被捕获，在再次抛出之前，return导致了Frame的出栈，从而导致后面的(athrow)没有执行，JVM的异常状态神奇的消失了。所以在代码实现上面，一定要避免这种有违异常约定的写法（eclipse也会提醒）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Java集合的那些事儿]]></title>
    <link href="http://crochengdu.github.io/blog/2014/06/09/java-collection/"/>
    <updated>2014-06-09T10:32:40+08:00</updated>
    <id>http://crochengdu.github.io/blog/2014/06/09/java-collection</id>
    <content type="html"><![CDATA[<h1>一、集合的体系结构</h1>

<p><img class="center" src="/images/collection.png" width="380" height="320"></p>

<p>Collection是集合的基类，List和Set均继承自该类。在使用上，List：有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引，元素可以重复，而Set中元素要保证不能重复。Map集合存储和Collection有着很大不同：
(1)Collection一次存一个元素；Map一次存一对元素。</p>

<p>(2)Collection是单列集合；Map是双列集合。</p>

<p>(3)Map中的存储的一对元素：一个是键，一个是值，键与值之间有对应(映射)关系。</p>

<h1>二、Set和Map的关系，以及Map和List的关系</h1>

<p>以HashMap为例，k-v键值对以Entry的方式存入了它的数据成员table，这个table我们可以认为它就是一个Set，因为这个table中的元素是彼此不相等；
反过来说，Set中的元素有一个索引与之对应，所以从这个角度看Set也是Map，而且我们可以从HashSet的实现看到，HashSet其实是通过HashMap来实现的；
Map和List的关系，与Map和Set的关系类似。</p>

<h1>三、ArrayList</h1>

<p>(1)使用场景</p>

<p>继承自List，内用Object[]数组存放数据，封装对数组的操作，动态扩容，频繁的增（超出capacity则需要System.arraycopy，指定插入位置必执行System.arraycopy）删（每次删除都要System.arraycopy）影响性能，查询优势。当你需要一个数据结构存储数据，少增删多查询，可以使用ArrayList。</p>

<p>(2)源码解读</p>

<p>ArrayList的add/remove/subList代码解读：
```java
public boolean add(E e) {
/*内部方法，计数并判断是否需要扩容
如果elementData已满，增加其大小至elementData.length + DEFAULT_CAPACITY</p>

<pre><code>    */
    ensureCapacityInternal(size + 1);
</code></pre>

<p>elementData[size++] = e;</p>

<pre><code>//永远返回true，对于错误情况总是抛出异常
    return true;
}
</code></pre>

<p>删除：
public E remove(int index) {</p>

<pre><code>//如果传入的index大于elementData存储总数，抛IndexOutOfBoundsException
    rangeCheck(index);
//修改记录数，为做同步检查
    modCount++;
    E oldValue = elementData(index);
//需要移动的数量。影响的是index之后的所有数据
    int numMoved = size - index - 1;
//如果移除的是最后一位，就没有必要重新拷贝。
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,numMoved);
//把多余的最后一位清空，GC会回收
    elementData[--size] = null;
    return oldValue;
</code></pre>

<p>}</p>

<p>SubList（代码比较长，摘取部分）
  //constructor
SubList(AbstractList<E> parent,</p>

<pre><code>            int offset, int fromIndex, int toIndex) {
  this.parent = parent; //将当前arraylist以参数形式传给subList
  this.parentOffset = fromIndex;
  this.offset = offset + fromIndex;
  this.size = toIndex - fromIndex; //记录sublist的size，与parent分开处理
  this.modCount = ArrayList.this.modCount; //防控并发修改
</code></pre>

<p>}
public E set(int index, E e) {</p>

<pre><code>  rangeCheck(index); //sublist自身的方法，将index与sublist的size做比较
  checkForComodification(); //只检查了ModCount，没有变更。Set不是结构性变更，所以不用更改modCount。
  E oldValue = ArrayList.this.elementData(offset + index);
  ArrayList.this.elementData[offset + index] = e; //直接修改父类的数据
  return oldValue;
</code></pre>

<p>}
//对于sublist的add方法，必须指定index
  public void add(int index, E e) {</p>

<pre><code>    rangeCheckForAdd(index);
    checkForComodification();
    parent.add(parentOffset + index, e);//调用parent对象的add方法完成此操作,因此父类数据也会被修改。
    this.modCount = parent.modCount;//add是结构性的更变，需要修改modCount。
    this.size++;
}
</code></pre>

<p>```
初始capacity为10, 视应用情况使用ensureCapacity为数组扩容，减少System.arraycopy的次数。</p>

<h1>四、HashMap</h1>

<p>HashMap是线程不安全的
HashTable是线程安全的，但是粒度很大
ConcurrentHashMap, 线程安全，粒度比较小
利用segment缩小锁的范围</p>

<p>(1)、从HashMap的结构可以看出，HashMap的设计初衷是想结合链表和线性表的优势而达到较平衡的查询、添加和删除性能。</p>

<p>(2)、源码分析</p>

<p>Hash方法中，hashcode 的高位参加 hash计算，这样计算出来的hash值可以最大限度的体现对象之间的差异，目的是将对象放在不同的数组位置上。</p>

<p>Index方法中，对hash取模操作，这里的magic是length的长度是2的幂数，length-1后二进制都是01111…1, 从而可以快速取模。
```java
static int hash(int h) {</p>

<pre><code>h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
</code></pre>

<p>}</p>

<p>static int indexFor(int h, int length) {</p>

<pre><code>return h &amp; (length-1);
</code></pre>

<p>}
```</p>

<p>GET取出的过程
1 判断key是不是为空，为空的话，默认在table[0]这个链表里找;
2 key非空的话，通过对hashcode进行hash，算出最终的hash值;
3 通过indexfor方法找到对应的链表table[i];
4 在链表里，通过比较对象的hash值和key值。如果完全相同的话，返回对象。如果没有找到，返回null。
```java
public V get(Object key) {</p>

<pre><code>if (key == null)
    return getForNullKey();
int hash = hash(key.hashCode());
for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
    e != null;
    e = e.next) {
    Object k;
    if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))
        return e.value;
}
return null;
</code></pre>

<p>}</p>

<p>static int indexFor(int h, int length) {</p>

<pre><code>return h &amp; (length-1);
</code></pre>

<p>}
```
(3)、Fail-first机制</p>

<p>HashMap不是线程安全。HashMap中有个成员变量modCount用来计算保障当前的map数据没有其它线程在同时修改。
如果有多个线程同时修改，会抛出ConcurrentModificationException看如下代码，用hashiterator方法来遍历map的时候，
 expectedModCount会被赋予最新的modCount值，调用nextEntry时，检查modCount值相等则不会报错。
调用iterator的remove方法，会让modCount加1，同时expectedModCount也被更新到最新。
所以下次在调用nextEntry时，连个值还是相等的。
```java</p>

<pre><code>        HashIterator() {
        expectedModCount = modCount;
        if (size &gt; 0) { // advance to first entry
            Entry[] t = table;
            while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)
                ;
        }
    }

        final Entry&lt;K,V&gt; nextEntry() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        Entry&lt;K,V&gt; e = next;
        if (e == null)
            throw new NoSuchElementException();

        if ((next = e.next) == null) {
            Entry[] t = table;
            while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)
                ;
        }
        current = e;
        return e;
    }

    public void remove() {
        if (current == null)
            throw new IllegalStateException();
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        Object k = current.key;
        current = null;
        HashMap.this.removeEntryForKey(k);
        expectedModCount = modCount;
    }
</code></pre>

<p>```</p>

<h1>五、HashSet</h1>

<p>HashSet 不会保证iterable的顺序，LinkedHashSet会保证插入的顺序跟你的iterable的顺序一样
两条规则实现hashCode()在classes：
1.如果object1 和 object2 equals（），那么他们2个应该有相同的hashcode
2.如果object1 和 object2 有一样的hashcode,那么他们不一定会equal.</p>

<p>HashSet源码解读
```java
public class HashSet<E></p>

<pre><code>extends AbstractSet&lt;E&gt;
implements Set&lt;E&gt;, Cloneable, java.io.Serializable
</code></pre>

<p>{</p>

<pre><code>static final long serialVersionUID = -5024744406713321676L;

//使用HashMap的key保存HashSet中的所有元素
private transient HashMap&lt;E,Object&gt; map;

// Dummy value to associate with an Object in the backing Map
//定义一个虚拟的Object对象作为HashMap的value
private static final Object PRESENT = new Object();

/**
 * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has
 * default initial capacity (16) and load factor (0.75).
 */
 //初始化HashSet，底层会初始化一个HashMap
public HashSet() {
map = new HashMap&lt;E,Object&gt;();
}
</code></pre>

<p>//指定初始容量和loadfactor来初始化HashSet，其实就是初始化HashMap</p>

<pre><code> //loadfactor = 散列表的实际元素数目（n）/ 散列表的容量（m）
public HashSet(int initialCapacity, float loadFactor) {
map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);
}

/**
 * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has
 * the specified initial capacity and default load factor (0.75).
 *
 * @param      initialCapacity   the initial capacity of the hash table
 * @throws     IllegalArgumentException if the initial capacity is less
 *             than zero
 */
public HashSet(int initialCapacity) {
map = new HashMap&lt;E,Object&gt;(initialCapacity);
}

/**
 * Constructs a new, empty linked hash set.  (This package private
 * constructor is only used by LinkedHashSet.) The backing
 * HashMap instance is a LinkedHashMap with the specified initial
 * capacity and the specified load factor.
 *
 * @param      initialCapacity   the initial capacity of the hash map
 * @param      loadFactor        the load factor of the hash map
 * @param      dummy             ignored (distinguishes this
 *             constructor from other int, float constructor.)
 * @throws     IllegalArgumentException if the initial capacity is less
 *             than zero, or if the load factor is nonpositive
 */
HashSet(int initialCapacity, float loadFactor, boolean dummy) {
map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);
}

/**
 * Returns an iterator over the elements in this set.  The elements
 * are returned in no particular order.
 *
 * @return an Iterator over the elements in this set
 * @see ConcurrentModificationException
 */
 //调用Map的keyset来返回迭代器
public Iterator&lt;E&gt; iterator() {
return map.keySet().iterator();
}
</code></pre>

<p>/**</p>

<pre><code> * Adds the specified element to this set if it is not already present.
 * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if
 * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that
 * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.
 * If this set already contains the element, the call leaves the set
 * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.
 *
 * @param e element to be added to this set
 * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified
 * element
 */
 //将e作为key插入了Hashmap
public boolean add(E e) {
return map.put(e, PRESENT)==null;
}
</code></pre>

<p>/**</p>

<pre><code> * Returns a shallow copy of this &lt;tt&gt;HashSet&lt;/tt&gt; instance: the elements
 * themselves are not cloned.
 *
 * @return a shallow copy of this set
 */
 //拷贝通过两步完成:1、通过调用super.clone完成父类的拷贝；2、通过调用map.clone()完成对成员变量map的拷贝。注意map的拷贝也是调用super.clone完成，所以拷贝都是浅拷贝。另外需要注意拷贝过程会抛出CloneNotSupportedException异常，这是一个检查异常。
public Object clone() {
try {
    HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();
    newSet.map = (HashMap&lt;E, Object&gt;) map.clone();
    return newSet;
} catch (CloneNotSupportedException e) {
    throw new InternalError();
}
}
</code></pre>

<p>```</p>

<h1>六、ArrayList vs LinkedList</h1>

<p>ArrayList，实现是一个数组，动态扩容，每次当超出capacity, 就把数组的size扩大，然后把以前的内容copy到新的数组里面去。</p>

<p>ArrayList 如何实现的fail-fast策略，是在每个对于ArrayList结构发生变化的方法里面(比如：add, remove)，都有个modCount这样的变量来记录，然后在iterator里面，构造iterator时候，把modcount 赋值给 exceptCount, 然后check是否相等这2个变量。</p>

<p>LinkedList, 实现是一个双向链表。</p>

<pre><code>            ArrayList,      LinkedList
</code></pre>

<p>Get(index)      O(1)            O(n)
Add             O(1)            O(1)
Remove      O(n &ndash; index)          O(1)
Fail-fast的实现，modifyCount != exceptiedCount.
它们2个都是线程不安全的。</p>

<h1>七、好的实践</h1>

<h2>使用LinkedHashMap构建LRU缓存</h2>

<p>(1) LRU缓存
我们用缓存来存放以前读取的数据，而不是直接丢掉，这样，再次读取的时候，可以直接在缓存里面取，而不用再重新查找一遍，这样系统的反应能力会有很大提高。但是，当我们读取的个数特别大的时候，我们不可能把所有已经读取的数据都放在缓存里，毕竟内存大小是一定的，我们一般把最近常读取的放在缓存里。
LRU缓存利用了这样的一种思想。LRU是Least Recently Used 的缩写，翻译过来就是“最近最少使用”，也就是说，LRU缓存把最近最少使用的数据移除，让给最新读取的数据。而往往最常读取的，也是读取次数最多的，所以，利用LRU缓存，我们能够提高系统的性能。
(2) 为什么是LinkedHashMap
第一，它的数据结构包含一个双向链表，其源代码片段如下：
```java
public class LinkedHashMap&lt;K,V>  extends HashMap&lt;K,V>  implements Map&lt;K,V> {</p>

<pre><code>/**
 * The head of the doubly linked list.
 */
private transient Entry&lt;K,V&gt; header;
</code></pre>

<p>其中Entry的定义的代码片段如下：
/<em>*                                                                     <br/>
 * LinkedHashMap entry.                                                 <br/>
 </em>/                                                                     <br/>
private static class Entry&lt;K,V> extends HashMap.Entry&lt;K,V> {</p>

<pre><code>// These fields comprise the doubly linked list used for iteration.   
Entry&lt;K,V&gt; before, after;
</code></pre>

<p><code>
可见这个双向链表就具备了实现LRU的基础，每次访问LinkedHashMap里的元素或者向LinkedHashMap里添加元素时，都会更新这个双向链表，让其header永远指向最少使用的元素，其代码实现可以参考LinkedHashMap的源代码。
第二，LinkedHashMap本身有一个方法用于判断是否需要移除最少使用的元素，但是，原始方法默认不需要移除，该方法实现的源代码如下：
</code>java
protected boolean removeEldestEntry(Map.Entry&lt;K,V> eldest) {</p>

<pre><code>    return false;
</code></pre>

<p>}<br/>
<code>                
实际使用中，可以将header指向的最少使用的元素作为该方法的入参，然后重写方法  removeEldestEntry，可以根据自己的条件来决定是否删除该元素。
(3) 实现样例
基于以上的分析，下面给出一个简单的LUR缓存的实现样例，代码如下：
</code>java
public class LRULinkedHashMap&lt;K, V> extends LinkedHashMap&lt;K, V> {</p>

<pre><code>/** serialVersionUID */
private static final long serialVersionUID = -5933045562735378538L;
/** 最大数据存储容量 */
private static final int LRU_MAX_CAPACITY = 1024;
/** 剩余内存空间的阈值，设置的为50M */
private static final int SPACE_THRESHOLD = 50 * 1024 * 1024; 
</code></pre>

<p>/<em>* 存储数据容量 </em>/</p>

<pre><code>private int capacity;
public LRULinkedHashMap() {
    super();
}

/**
 * 带参数构造方法
 * 
 * @param initialCapacity 容量
 * @param loadFactor 装载因子
 * @param isLRU 是否使用lru算法，true：使用（按方案顺序排序）;false：不使用（按存储顺序排序）
 */
public LRULinkedHashMap(int initialCapacity, float loadFactor, boolean isLRU) {
    super(initialCapacity, loadFactor, true);
    capacity = LRU_MAX_CAPACITY;
}

/**
 * 带参数构造方法
 * 
 * @param initialCapacity 容量
 * @param loadFactor 装载因子
 * @param isLRU 是否使用lru算法，true：使用（按方案顺序排序）;false：不使用（按存储顺序排序）
 * @param lruCapacity  lru存储数据容量
 */
public LRULinkedHashMap(int initialCapacity, float loadFactor,
        boolean isLRU, int lruCapacity) {
    super(initialCapacity, loadFactor, true);
    this.capacity = lruCapacity;
}

@Override
protected boolean removeEldestEntry(Entry&lt;K, V&gt; eldest) {
    if (capacity &gt; 0 &amp;&amp; size() &gt; capacity) {
        return true;
    } else if (Runtime.getRuntime().freeMemory() &lt; SPACE_THRESHOLD) {
        return true;
    }
    return false;
}
} 
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
